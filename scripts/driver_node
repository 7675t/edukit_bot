#!/usr/bin/env python

import rospy
from std_msgs.msg import Float32
from geometry_msgs.msg import Twist

import RPi.GPIO as GPIO


# Set the GPIO modes
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

_FREQUENCY = 20


def _saturate(value, min, max):
    if value < min:
        return min
    elif value > max:
        return max
    return value


class Motor:
    def __init__(self, forward_pin, backward_pin):
        self._forward_pin = forward_pin
        self._backward_pin = backward_pin

        GPIO.setup(forward_pin, GPIO.OUT)
        GPIO.setup(backward_pin, GPIO.OUT)

        self._forward_pwm = GPIO.PWM(forward_pin, _FREQUENCY)
        self._backward_pwm = GPIO.PWM(backward_pin, _FREQUENCY)

    def move(self, speed_percent):
        speed = _saturate(abs(speed_percent), 0, 100)
        if speed_percent < 0:
            self._backward_pwm.start(speed)
            self._forward_pwm.start(0)
        else:
            self._forward_pwm.start(speed)
            self._backward_pwm.start(0)

class Driver
    def __init__(self):
        rospy.init_node('driver')

        self._last_received = rospy.get_time()
        self._timeout = rospy.get_param('~timeout', 2)  # seconds
        self._rate = rospy.get_param('~rate', 10)
        self._max_speed = rospy.get_param('~max_speed', 30)  # percent

        self._left_motor = Motor(10, 9)
        self._right_motor = Motor(8, 7)
        self._left_speed = 0
        self._right_speed = 0

        # Setup subscriber for left and right wheel speeds
        rospy.Subscriber('left', Float32, self.left_wheel_callback)
        rospy.Subscriber('right', Float32, self.right_wheel_callback)

    def left_wheel_callback(self, message):
        self._left_speed = message.data
        self._last_received = rospy.get_time()

    def right_wheel_callback(self, message):
        self._right_speed = message.data
        self._last_received = rospy.get_time()

    def run(self):
        rate = rospy.Rate(self._rate)

        while not rospy.is_shutdown():
          if (rospy.get_time() - self._last_received) < self._timeout:
              self._left_motor.move(self._left_speed)
              self._right_motor.move(self._right_speed)
          else:
              self._left_motor.move(0)
              self._right_motor.move(0)
          rate.sleep()
            

def main():
    driver = Driver()

    # Run driver. This will block
    driver.run()


if __name__ == '__main__':
    main()
